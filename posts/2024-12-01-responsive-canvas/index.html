<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta property="og:title" content="Responsive Canvas" />
    <meta property="og:type" content="article" />
    
    <meta
      property="og:image"
      content="https://ates.dev/posts/2024-12-01-responsive-canvas/i/responsive-canvas.png"
    />
    
    <meta property="og:locale" content="en_CA" />
    <meta property="og:site_name" content="ates.dev" />
    <title>ates.dev &middot; Responsive Canvas</title>
    <link
      rel="icon"
      type="image/png"
      href="/assets/icons/favicon-96x96.png"
      sizes="96x96"
    />
    <link rel="icon" type="image/svg+xml" href="/assets/icons/favicon.svg" />
    <link rel="shortcut icon" href="/assets/icons/favicon.ico" />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="/assets/icons/apple-touch-icon.png"
    />
    <meta name="apple-mobile-web-app-title" content="ates.dev" />
    <link rel="manifest" href="/assets/icons/site.webmanifest" />
    <link rel="stylesheet" href="/styles/style.css" />
    <script src="/assets/js/prog.js?bust=1"></script>
  </head>
  <body>
    <header>
      <h1><a href="/">ates.dev</a></h1>
    </header>

    <main>
<article>
  <h2>Responsive Canvas</h2>
  <p class="meta">Posted on December 01, 2024</p>

  <div class="content"><script>
function tailDebounce(fn, delay) {
  let timer;

  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

const visibilityCallbacks = new WeakMap();

const visibilityObserver = new IntersectionObserver((entries) => {
  for (const entry of entries) {
    entry.target.setAttribute('data-in-viewport', entry.isIntersecting);
    visibilityCallbacks.get(entry.target)?.(entry.isIntersecting);
  }
}, {
  threshold: 0.5,
});

const resizeCallbacks = new WeakMap();

const resizeObserver = new ResizeObserver((entries) => {
  for (const entry of entries) {
    if (entry.contentRect) {
      resizeCallbacks.get(entry.target)?.();
    }
  }
});

function render(id, {init, draw, resize = true}) {
  const canvas = document.querySelector(`#${id}`);
  const ctx = canvas.getContext("2d");
  let visible = false;
  let rafId = null;

  function initOnRaf() {
    requestAnimationFrame(() => {
      init(canvas, ctx);
      // draw && draw(ctx, 0);
    });
  }

  function raf(draw) {
    rafId = requestAnimationFrame((t) => {
      raf(draw);
      draw(ctx, t);
    });
  }

  if (init) {
    initOnRaf();
  }

  if (draw) {
    visibilityCallbacks.set(canvas, (newVisible) => {
      if (newVisible) {
        if (!visible) {
          raf(draw);
        }
      } else {
        if (visible && rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
      }

      visible = newVisible;
    });

    visibilityObserver.observe(canvas);
  }

  if (resize && init) {
    const debouncedInitOnRaf = tailDebounce(initOnRaf, 100);

    resizeCallbacks.set(canvas, debouncedInitOnRaf);
    resizeObserver.observe(canvas);
  }
}

function initDprDemo(canvas, ctx, forceDpr) {
  const dpr = window.devicePixelRatio;
  const usedDpr = forceDpr || dpr;

  canvas.width = canvas.clientWidth * usedDpr;
  canvas.height = canvas.clientHeight * usedDpr;

  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const RADIUS = 50;

  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.arc(
    canvas.width / 2,
    canvas.height / 2,
    RADIUS * usedDpr,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Display DPR
  ctx.font = '2em monospace';
  ctx.fillText(usedDpr.toFixed(1), 10, 35);

  // 20x20 pixel reference square
  ctx.fillRect(10, 50, 20, 20);
}
</script>
<p>&quot;Responsive&quot; in web development pertains to, in a nutshell, layout: Adjusting the
layout of a page based on the dimensions of the renderable area. A more formal
definition from <a href="https://en.wikipedia.org/wiki/Responsive_web_design">Wikipedia</a>:</p>
<blockquote>
<p>Responsive web design (RWD) or responsive design is an approach to web design
that aims to make web pages render well on a variety of devices and window or
screen sizes from minimum to maximum display size to ensure usability and
satisfaction.</p>
</blockquote>
<p>Here, I will share a few key techniques I always apply when rendering pixels on
a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API"><code>&lt;canvas&gt;</code></a> element, while keeping the rendering properly respond to these
factors:</p>
<ol>
<li>Canvas size</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio">Device Pixel Ratio</a> (DPR)</li>
<li>Time</li>
</ol>
<p>Also, how to compose a scene (i.e. define the dimensions of elements) while
taking 1-3 into consideration, without getting into an unmaintainable mess.</p>
<p>This is not a comprehensive tutorial that aims to teach on canvas rendering from
scratch. Code excerpts are partial, only highlighting key changes from the
previous example. Knowledge of JavaScript and some algebra is assumed. This
will progressively get more complicated, fast.</p>
<h3 id="defaults" tabindex="-1"><a class="permalink" href="#defaults">Defaults</a></h3>
<p>Let's start with a default canvas:</p>
<pre><code class="language-html">&lt;canvas&gt;&lt;/canvas&gt;
</code></pre>
<p class="canvas-container">
  <canvas id="canvas-default" class="bordered"></canvas>
</p>
<p>By default, it is a transparent rectangle measuring 300 by 150 pixels
(<a href="https://html.spec.whatwg.org/multipage/canvas.html#the-canvas-element:~:text=The%20width%20attribute%20defaults%20to%20300%2C%20and%20the%20height%20attribute%20defaults%20to%20150.">spec</a>). I have added a border around it to clearly define its size and
position on the page.</p>
<p>Now, let's fill it black and then render a 100x100 white square in its middle:</p>
<pre><code class="language-html">&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
</code></pre>
<pre><code class="language-js">const canvas = document.querySelector(&quot;#canvas&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);

ctx.fillRect(0, 0, canvas.width, canvas.height);

const SIZE = 100;

ctx.fillStyle = &quot;white&quot;;
ctx.fillRect(
  canvas.width / 2 - SIZE / 2,
  canvas.height / 2 - SIZE / 2,
  SIZE,
  SIZE
);
</code></pre>
<p class="canvas-container">
  <canvas id="canvas-with-square" class="black"></canvas>
</p>
<script>
render('canvas-with-square', {
  init(canvas, ctx) {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const SIZE = 100;

    ctx.fillStyle = 'white';
    ctx.fillRect(
      canvas.width / 2 - SIZE / 2,
      canvas.height / 2 - SIZE / 2,
      SIZE,
      SIZE
    );
  },
});
</script>
<h3 id="stretching" tabindex="-1"><a class="permalink" href="#stretching">Stretching</a></h3>
<p>Now let's stretch the canvas to 100% of the width of the container:</p>
<pre><code class="language-css">canvas {
  width: 100%;
  height: 150px;
}
</code></pre>
<p class="canvas-container">
  <canvas id="canvas-with-square-fit" class="fit black"></canvas>
</p>
<script>
render('canvas-with-square-fit', {
  init(canvas, ctx) {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const SIZE = 100;

    ctx.fillStyle = 'white';
    ctx.fillRect(
      canvas.width / 2 - SIZE / 2,
      canvas.height / 2 - SIZE / 2,
      SIZE,
      SIZE
    );
  },
});
</script>
<p>What happened to our perfectly square square? Because we resized the canvas with
CSS and didn't attach <code>width</code> and <code>height</code> attributes to the <code>&lt;canvas&gt;</code> tag, the
intrinsic dimensions of the canvas are still the defaults, 300x150.</p>
<p>To fix the dimensions of the rendering context, we can set the <code>width</code> and
<code>height</code> properties of the canvas DOM element to the measured pixel dimensions:</p>
<pre><code class="language-js">canvas.width = canvas.clientWidth;
canvas.height = canvas.clientHeight;
</code></pre>
<p class="canvas-container">
  <canvas id="canvas-with-square-fit-fix" class="fit black"></canvas>
</p>
<script>
render('canvas-with-square-fit-fix', {
  init(canvas, ctx) {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const SIZE = 100;

    ctx.fillStyle = 'white';
    ctx.fillRect(
      canvas.width / 2 - SIZE / 2,
      canvas.height / 2 - SIZE / 2,
      SIZE,
      SIZE
    );
  },
});
</script>
<h3 id="crisp-rendering" tabindex="-1"><a class="permalink" href="#crisp-rendering">Crisp rendering</a></h3>
<p>Next, let's switch to rendering a circle to achieve anti-aliased edges. And let's also print &quot;1.0&quot;, and render a reference 20x20 square, both of which will become significant soon.</p>
<pre><code class="language-js">const RADIUS = 50;

ctx.beginPath();
ctx.arc(canvas.width / 2, canvas.height / 2, RADIUS, 0, Math.PI * 2);
ctx.fill();

ctx.font = '2em monospace';
ctx.fillText('1.0', 10, 35);

// 20x20 pixel reference square
ctx.fillRect(10, 50, 20, 20);
</code></pre>
<p class="canvas-container">
  <canvas id="canvas-with-circle" class="fit black"></canvas>
</p>
<script>
render('canvas-with-circle', {
  init: (canvas, ctx) => initDprDemo(canvas, ctx, 1)
});
</script>
<p>The CSS dimensions we set on the canvas are the logical pixel dimensions. Your browser's DPR (Device Pixel Ratio) is a multiplier that determines the physical pixel density of your screen. For example, if your DPR is <code>2.0</code>, then for every logical pixel, there are 4 physical pixels (2x2). To render this circle in the
crispiest way possible we will apply the DPR as a multiplier to the
canvas dimensions. We'll also print your actual DPR instead of the &quot;1.0&quot; we hard-coded earlier:</p>
<pre><code class="language-js">const dpr = window.devicePixelRatio;

canvas.width = canvas.clientWidth * dpr;
canvas.height = canvas.clientHeight * dpr;
</code></pre>
<p>But then, we also have to start factoring in DPR in all size units when using
the drawing primitives:</p>
<pre><code class="language-js">ctx.beginPath();
ctx.arc(
  canvas.width / 2,
  canvas.height / 2,
  RADIUS * dpr, // Adjust for DPR
  0,
  Math.PI * 2
);
ctx.fill();

// Display DPR
ctx.font = '2em monospace';
ctx.fillText(dpr.toFixed(2), 10, 35);
</code></pre>
<p class="canvas-container">
  <canvas id="canvas-with-circle-dpr" class="fit black"></canvas>
</p>
<script>
render('canvas-with-circle-dpr', {
  init: (canvas, ctx) => initDprDemo(canvas, ctx)
});
</script>
<p>If your DPR is greater than <code>1.0</code>, you should see the 20x20 pixel reference
square rendered as something smaller than 20x20 while our circle remains the
same size. And the anti-aliased edges of the circle should now look as crisp as
physically possible on your screen (without getting into subpixel rendering).</p>
<p>In case your DPR is <code>1.0</code>, and you don't see a difference above, here's what the
comparison would have <strong>approximately</strong> looked like against a DPR of <code>2.0</code>:</p>
<p class="canvas-container">
  <canvas id="canvas-dpr-compare" class="fit black"></canvas>
</p>
<script>
render('canvas-dpr-compare', {
  draw: (ctx, t) => {
    const canvas = ctx.canvas;
    const dpr = window.devicePixelRatio;

    canvas.width = canvas.clientWidth * dpr;
    canvas.height = canvas.clientHeight * dpr;

    const s = t / 1000 | 0;
    const fakeDpr = 2;
    const virtualDpr = s & 1 ? fakeDpr : 1;

    ctx.reset();
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const scale = dpr / virtualDpr;

    ctx.scale(scale, scale);

    const RADIUS = 50;

    const x = canvas.width / 2 / scale;
    const y = canvas.height / 2 / scale;
    const r = RADIUS * virtualDpr * virtualDpr / fakeDpr;

    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();

    // Display DPR
    ctx.font = '2em monospace';
    ctx.fillText(virtualDpr.toFixed(1), 10, 35);

    // 20x20 pixel reference square
    ctx.fillRect(10, 50, 20, 20);

    ctx.imageSmoothingEnabled = false;

    const u = r * 2 / virtualDpr;

    ctx.drawImage(
      canvas,
      (x - r) * scale, (y - r) * scale, r * 2 * scale, r * 2 * scale,
      x - u, y - u, u * 2, u * 2
    );

    const zx = x + Math.cos(Math.PI / 4) * u;
    const zy = y - Math.sin(Math.PI / 4) * u;

    ctx.drawImage(
      canvas,
      (zx - u / 6) * scale, (zy - u / 6) * scale, u / 3 * scale, u / 3 * scale,
      x + u + u / 3, y - u + u / 3, u / 3 * 4, u / 3 * 4,
    );

    ctx.strokeStyle = '#00c0ff';
    ctx.lineWidth = 3 / scale;

    ctx.strokeRect(zx - u / 6, zy - u / 6, u / 3, u / 3);
    ctx.strokeRect(
      x + u + u / 3,
      y - u + u / 3,
      u / 3 * 4,
      u / 3 * 4,
    );

    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2 / scale;

    ctx.strokeRect(
      zx - u / 6 + 1 / scale,
      zy - u / 6 + 1 / scale,
      u / 3 - 2 / scale,
      u / 3 - 2 / scale,
    );
    ctx.strokeRect(
      x + u + u / 3 + 1 / scale,
      y - u + u / 3 + 1 / scale,
      u / 3 * 4 - 2 / scale,
      u / 3 * 4 - 2 / scale,
    );
  }
});
</script>
<h3 id="layout" tabindex="-1"><a class="permalink" href="#layout">Layout</a></h3>
<p>In the examples so far we've used hard-coded dimensions for the elements because
we knew the canvas height was always 150px. A square 100px across or a circle
50px in radius would nicely fit.</p>
<p>When the canvas size is dynamic, I find it easier to define the scene in terms
of proportions, typically as a fraction of the canvas height. So, let's switch
to rendering our circle with a radius of 1/6th of the canvas height:</p>
<pre><code class="language-js">const radius = canvas.height / 6;

ctx.fillStyle = 'white';
ctx.beginPath();
ctx.arc(
  canvas.width / 2,
  canvas.height / 2,
  radius * dpr,
  0,
  Math.PI * 2
);
ctx.fill();
</code></pre>
<script>
  function drawCircleScene(ctx) {
    const canvas = ctx.canvas;
    const dpr = window.devicePixelRatio;

    canvas.width = canvas.clientWidth * dpr;
    canvas.height = canvas.clientHeight * dpr;

    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const radius = canvas.height / 6;

    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(
      canvas.width / 2,
      canvas.height / 2,
      radius * dpr,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }
</script>
<p class="canvas-container">
  <span class="canvas-subcontainer">
    <canvas id="canvas-resize-layout" class="fit black"></canvas>
  </span>
</p>
<script>
  render('canvas-resize-layout', {
    resize: false,
    init: (_canvas, ctx) => drawCircleScene(ctx)
  });
</script>
<h3 id="resizing" tabindex="-1"><a class="permalink" href="#resizing">Resizing</a></h3>
<p>Typically, a canvas will be dynamically resized based on the size of a
container, using CSS.</p>
<p class="canvas-container">
  <span class="canvas-subcontainer auto-resize">
    <canvas id="canvas-resize-stretch" class="fit black bordered"></canvas>
  </span>
</p>
<script>
  render('canvas-resize-stretch', {
    resize: false,
    init: (_canvas, ctx) => drawCircleScene(ctx)
  });
</script>
<p class="canvas-container">
  <span class="canvas-subcontainer auto-resize">
    <canvas id="canvas-resize-draw" class="fit black bordered"></canvas>
  </span>
</p>
<script>
  render('canvas-resize-draw', {
    resize: false,
    draw: (ctx) => drawCircleScene(ctx)
  });
</script>
<p class="canvas-container">
  <span class="canvas-subcontainer auto-resize" style="width: 300px; height: auto; aspect-ratio: 300 / 150;">
    <canvas id="canvas-resize-stretch-ar" class="black bordered" style="width: 100%; height: 100%;"></canvas>
  </span>
</p>
<script>
  render('canvas-resize-stretch-ar', {
    resize: false,
    init: (_canvas, ctx) => drawCircleScene(ctx)
  });
</script>
<p class="canvas-container">
  <span id="canvas-resize-stretch-tiny-container" class="canvas-subcontainer" style="width: 80px; height: 40px;">
    <canvas id="canvas-resize-stretch-tiny" class="black" style="width: 100%; height: 100%;"></canvas>
  </span>
</p>
<script>
  render('canvas-resize-stretch-tiny', {
    resize: false,
    init: (canvas, ctx) => {
      drawCircleScene(ctx);

      const container = document.querySelector('#canvas-resize-stretch-tiny-container');
      container.style.width = '300px';
      container.style.height = '150px';
    }
  });
</script>
<script>
  const autoResizables = document.querySelectorAll('.canvas-subcontainer.auto-resize');

  setInterval(() => {
    const width = `${Math.random() * 100 + 200}px`

    autoResizables.forEach((el) => {
      el.style.width = width;
    });
  }, 1000);
</script>
</div>
</article>
</main>

    <footer>
      <hr />
      <p class="footer meta">
        &copy; Ateş Göral &middot; A GitHub Pages site running on Eleventy:
        <a href="https://github.com/atesgoral/ates.dev"
          >github.com/atesgoral/ates.dev</a
        >
      </p>
    </footer>
  </body>
</html>
